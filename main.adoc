:!chapter-signifier:
:toc:
:toclevels: 6
:sectanchorts:
:sectnums:
:icons: font
:source-highlighter: rouge
:asciimath:
:doctype: book

= Αλγόριθμοι Σύστασης με Χρήση Τεχνητών Νευρωνικών Δικτύων και Τεχνικών Ομαδοποίησης Δεδομένων

== Θέμα 1: Προ-επεξεργασία Δεδομένων

Προτού προχωρήσουμε στις απαντήσεις των ερωτημάτων, φορτώνουμε τα δεδομένα ως ένα latexmath:[dataframe] χρησιμοποιώντας τις βιβλιοθήκες numpy και pandas της Python.

----
import numpy as np
import pandas as pd


def load_dataframe():

    # Load the dataset
    dataset = np.load('Dataset.npy')
    # Convert to dataframe
    X = pd.DataFrame(dataset)

    return X
----

Εκτυπώνοντας το latexmath:[head] του latexmath:[dataframe], έχουμε μια προεσκόπιση της δομής των δεδομένων μας (figure 1).

----
# Print the first five entries
X = load_dataframe()
print(X.head())
----

.Προεσκόπιση δεδομένων από Dataset.npy
image::img1.png[200, 400]

<<<


=== Ερώτημα 1

Βρίσκουμε τις στήλες latexmath:[users] (στήλη 1) και latexmath:[items] (στήλη 2) του latexmath:[dataframe] και καλούμε τη μέθοδο latexmath:[nunique] για να βρούμε τα πλήθη των μοναδικών χρηστών και αντικειμένων.

----

from dataset import load_dataframe

X = load_dataframe()

# Split the users' and items' columns
X['users'] = X[0].str.split(',').str[0]
X['items'] = X[0].str.split(',').str[1]

# Getting the unique count of users and items
unique_users = X['users'].nunique()
unique_items = X['items'].nunique()

print("Unique count of users:", unique_users)
print("Unique count of items:", unique_items)

----

Εκτυπώνοντας στην οθόνη βλέπουμε το παρακάτω αποτέλεσμα.

.Count of unique users and items
image::img2.png[200, 400]

<<<


=== Ερώτημα 2

Καλούμε τη μέθοδο latexmath:[load_dataframe] και υπολογίζουμε πόσες φορές εμφανίζεται κάθε χρήστης για να βρούμε τα άκρα των δεδομένων μας. Παρατηρούμε ότι κανένας χρήστης δεν έχει δώσει πάνω από 29 αξιολογήσεις (πάνω όριο).

Επιλέγουμε το υποσύνολο που βρίσκεται μεταξύ latexmath:[Rmin = 3] και latexmath:[Rmax = 50]. Τώρα τα δεδομένα μας έχουν μήκος 358.

Στη συνέχεια φτιάχνουμε το latexmath:[dataframe R] που προκύπτει από τους χρήστες που έχουμε φιλτράρει και δίνουμε στις στήλες του τα αντίστοιχα ονόματα: latexmath:[Users, Items, Ratings, Timestamp].

Τέλος, μετατρέπουμε τα δεδομένα των πρώτων τριών στηλών σε latexmath:[integers] και τα δεδομένα της τελευταίας στήλης σε latexmath:[datetime objects].

----

def R_dataframe():
    # Load the DataFrame
    X = load_dataframe()
    # Count the occurrences of each user
    user_counts = X.iloc[:, 0].value_counts()

    # Filter users who appear between Rmin = 3 and Rmax = 50 times (length: 358, for Rmax = 2 we'd have 8662)
    # no one has given more than 29 ratings
    filtered_users = user_counts[(user_counts >= 3) & (user_counts <= 50)]

    # Create R dataframe with rows of users appearing in filtered_users
    R = X[X.iloc[:, 0].isin(filtered_users.index)]
    # Splitting the single column into separate columns
    R = R[0].str.split(',', expand=True)
    R.columns = ['Users', 'Items', 'Ratings', 'Timestamp']

    # Convert to numeric values
    R['Ratings'] = pd.to_numeric(R['Ratings'])


    R['Users'] = R['Users'].str.extract('(\d+)').astype(int)
    R['Items'] = R['Items'].str.extract('(\d+)').astype(int)

    # Convert 'Timestamp' column to datetime object
    R['Timestamp'] = pd.to_datetime(R['Timestamp'])
    return R


# Print R
R = R_dataframe()
print(R)

----

<<<

Εκτυπώνοντας στην οθόνη βλέπουμε το παρακάτω αποτέλεσμα.

.Προεσκόπιση δεδομένων του R dataframe
image::img3.png[200, 400]

<<<

=== Ερώτημα 3

Για να αναπαραστήσουμε γραφικά τα ιστογράμματα του ερωτήματος, έχουμε χρησιμοποιήσει τη βιβλιοθήκη latexmath:[matplotlib] της Python.

==== Ιστόγραμμα συχνότητας για το πλήθος των αξιολογήσεων του κάθε χρήστη.

Φορτώνουμε το latexmath:[dataframe R] όπως υπολογίστηκε στο υπο-ερώτημα 2 και ομαδοποιούμε τα δεδομένα του ως προς τις αξιολογήσεις ανά μοναδικό χρήστη και φτιάχνουμε το ιστόγραμμα.

....

# Load the updated dataframe that occurred from Q2 where Rmin = 3 and Rmax = 50
R = R_dataframe()

# Grouping by the values of ratings and users
ratings_per_user = R.groupby('Ratings')['Users'].nunique()

plt.hist(ratings_per_user, bins=50)

# Plotting the histogram
ratings_per_user.plot(kind='bar', stacked=True)

# Setting labels and title
plt.xlabel('Ratings')
plt.ylabel('No. of Users')
plt.title('Histogram')

# Display the plot
plt.show()

....

<<<

Εκτυπώνοντας στην οθόνη βλέπουμε το παρακάτω αποτέλεσμα.

.Ιστόγραμμα συχνότητας για το πλήθος των αξιολογήσεων του κάθε χρήστη
image::img4.png[]

<<<

==== Ιστόγραμμα συχνότητας για το χρονικό εύρος των αξιολογήσεων του κάθε χρήστη.

Φορτώνουμε το latexmath:[dataframe R] όπως υπολογίστηκε στο υπο-ερώτημα 2 και ομαδοποιούμε τα δεδομένα των χρηστών υπολογίζοντας το ελάχιστο και μέγιστο διάστημα σε μέρες που μεσολάβησε για να δοθούν όλες οι αξιολογήσεις ανά χρήστη.

Τέλος, προσαρμόζουμε τις παραμέτρους της γραφικής αναπαράστασης του ιστογράμματος ώστε να είναι πιο ευανάγνωστη η πληροφορία.

....

# Load the updated dataframe that occurred from Q2 where Rmin = 3 and Rmax = 50
R = R_dataframe()

# Plotting the histogram
user_timestamp_range = (R.groupby('Users')['Timestamp']
                        .agg(lambda x: (x.max() - x.min()).days))

values, bins, _ = plt.hist(user_timestamp_range, bins=50)

# Showing only time ranges that matches user activity (non-zero values).
nonzero_indices = [i for i, val in enumerate(values) if val != 0]
plt.xticks(bins[nonzero_indices])

# Showing count of users for each time range
for i in range(len(bins) - 1):
    if values[i] != 0:  # Check if the count is non-zero
        plt.text(bins[i] + (bins[i+1] - bins[i]) / 2, values[i], str(int(values[i])), ha='center', va='bottom')

# Setting labels and title
plt.xlabel('Time range in days')
plt.ylabel('No. of Users')
plt.title('Histogram')

# Display the plot
plt.show()

....

<<<

Εκτυπώνοντας στην οθόνη βλέπουμε το παρακάτω αποτέλεσμα.

.Ιστόγραμμα συχνότητας για το χρονικό εύρος των αξιολογήσεων του κάθε χρήστη.
image::img5.png[]


== Θέμα 3: Αλγόριθμοι Παραγωγής Συστάσεων με Χρήση Τεχνητών Νευρωνικών Δικτύων

Εισάγουμε τις βιβλιοθήκες latexmath:[sklearn.cluster] και latexmath:[sklearn.metrics] και φορτώνουμε τα δεδομένα μας από τη συνάρτηση latexmath:[R_dataframe()].
....

R = R_dataframe()

....

Τα δεδομένα μετασχηματίζονται σε έναν πίνακα όπου κάθε σειρά αντιπροσωπεύει έναν χρήστη (user) και κάθε στήλη ένα αντικείμενο (item). Οι τιμές είναι οι βαθμολογίες (ratings).
....

# Dataframe where each row represents a user and each column represents an item
R = R.pivot_table(index='Users', columns='Items', values='Ratings', fill_value=0)

....

Εξάγουμε από το dataframe τα διανύσματα χαρακτηριστικών (feature vectors) για κάθε χρήστη.
....

# Feature vectors for each user
feature_vectors = R.values

....

Ορίζουμε τη συνάρτηση latexmath:[custom_jaccard_coefficient(u, v)] για να υπολογίσουμε το συντελεστή Jaccard μεταξύ δύο διανυσμάτων.

Στον ονομαστή του συντελεστή έχουμε τις ταινίες που αξιολόγησαν από κοινού οι χρήστες u και v και στον παρονομαστή την ένωση των ταινιών που αξιολόγησαν συνολικά.
....

# Custom Jaccard coefficient computation function
def custom_jaccard_coefficient(u, v):
    intersection = np.intersect1d(u, v)
    union = np.union1d(u, v)
    coefficient = 1.0 - len(intersection) / len(union)
    return coefficient

....

Ορίζουμε τον αριθμό των ομάδων (clusters) και αρχικοποιούμε τον αλγόριθμο latexmath:[KMeans].

....

# Set the number of clusters (L)
L = 3

# Initialize KMeans
kmeans = KMeans(n_clusters=L, init='k-means++')

....

Υπολογίζουμε τις αποστάσεις latexmath:[Jaccard].

....

# Compute the pairwise Jaccard distances between all pairs of users
pairwise_jaccard_distances = pairwise_distances(feature_vectors, metric=custom_jaccard_coefficient)

....

Εκπαιδεύουμε τον latexmath:[KMeans].

....

# Fit KMeans to the pairwise Jaccard distances
cluster_labels = kmeans.fit_predict(pairwise_jaccard_distances)
....

Εκτυπώνουμε τις ομάδες (clusters).

....

# Print the clusters
for cluster_idx in range(L):
    print("Cluster", cluster_idx, ":")
    cluster_users = np.where(cluster_labels == cluster_idx)[0]
    for user_idx in cluster_users:
        print("User", user_idx)
    print()

....

Ο κώδικας κατατάσσει τους χρήστες σε 3 ομάδες (clusters) χρησιμοποιώντας τον αλγόριθμο KMeans και αποστάσεις Jaccard, και εκτυπώνει τους χρήστες που ανήκουν σε κάθε ομάδα όπως φαίνονται παρακάτω.

.Cluster 1
image::3.1.1.png[]

.Cluster 2
image::3.1.2.png[]

.Cluster 3
image::3.1.3.png[]

=== Ερώτημα 1

Η μετρική αυτή ποσοτικοποιεί το πλήθος των κοινών αξιολογήσεων δυο χρηστών. Το κλάσμα μπορεί να πάρει τιμές απο 0 εως 1. Αν δύο χρήστες δεν έχουν καμία κοινή αξιολόγηση η απόσταση θα είναι ίση με 1. Διαφορετικά, αν έχουν αξιολογήσει και οι δυο το ίδιο σύνολο ταινιών η απόσταση θα είναι ιση με 0.

Κατά συνέπεια, η συγκεκριμένη μετρική δεν εστιάζει στο αν ο χρήστης u με το χρήστη v είχαν παρόμοιο τρόπο αξιολόγησης (αν τα γούστα τους δηλαδή μοιάζουν ή αν συσχετίζονται). Αγνοεί δηλαδή τις διαφορές στις τιμές των βαθμολογιών. Στην πραγματικότητα, αποδίδει μικρή απόσταση ανάμεσα σε δυο χρηστές όταν αυτοί έχουν αξιολογήσει το ίδιο σύνολο ταινιών και μεγαλύτερη απόσταση όσο τα σύνολα διαφοροποιούνται. Συνεπώς, με τη μετρική αυτή έχουμε απώλεια πληροφοριών που αφορούν στην ποσότητα.

Σε αντίθεση με τη μετρική Jaccard, η ευκλείδεια απόσταση λαμβάνει υπόψη τις διαφορές στις τιμές των βαθμολογιών. Είναι μια κλασική μετρική απόστασης που χρησιμοποιείται ευρέως και είναι καλά κατανοητή.

Η απόσταση συνημιτόνου (cosine similarity) μας δίνει το προφίλ ενός χρήστη συναρτήσει ενός άλλου με βάση την κατεύθυνση των διανυσμάτων. Συγκεκριμένα, ανάλογα με το πρόσημο του παράγοντα λ έχουμε θετική ή αρνητική συσχέτιση. Η μετρική αυτή, αν και πιο πολύπλοκη από την ευκλείδεια απόσταση, μπορεί να είναι χρήσιμη σε δεδομένα που η ομοιότητα κατεύθυνσης είναι πιο σημαντική από την ομοιότητα μεγέθους.

Τελικά, η επιλογή της κατάλληλης μετρικής εξαρτάται από τα χαρακτηριστικά των δεδομένων και το στόχο της ομαδοποίησης.